import fs from "fs";
import path from "path";
import { fileURLToPath } from "url";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const jsonDir = path.join(__dirname, "json");
const tsDir = path.join(__dirname, "ts");

// Cache for storing symbol definitions and module information
const symbolDefinitionCache = new Map();
const brandModules = new Set();

function ensureDirectoryExistence(filePath) {
  const dirname = path.dirname(filePath);
  if (!fs.existsSync(dirname)) {
    fs.mkdirSync(dirname, { recursive: true });
  }
}

/**
 * Splits a brand JSON file into multiple TypeScript files
 */
function splitBrandFile(brandName, jsonContent) {
  const { components, ...brandBase } = jsonContent;
  
  return {
    base: brandBase,
    components: components || {}
  };
}

/**
 * Creates a theme variation (light/dark) for a specific brand
 */
function createThemeVariation(theme, brandName, variation) {
  // Deep clone the theme object
  const brandTheme = JSON.parse(JSON.stringify(theme));
  
  // Update references to point to the specific brand
  JSON.stringify(brandTheme, (key, value) => {
    if (typeof value === 'string' && value.includes('brand.')) {
      // Update brand references to point to the specific brand
      return value.replace(/\{brand\./g, `{${brandName}.`);
    }
    return value;
  });

  return brandTheme;
}

/**
 * Builds a complete map of symbol definitions including brand information
 */
function buildSymbolDefinitionMap() {
  function scanDirectory(dir) {
    const files = fs.readdirSync(dir, { withFileTypes: true });
    
    for (const file of files) {
      const fullPath = path.join(dir, file.name);
      
      if (file.isDirectory()) {
        scanDirectory(fullPath);
      } else if (file.isFile() && file.name.endsWith('.json')) {
        try {
          const content = JSON.parse(fs.readFileSync(fullPath, 'utf8'));
          const relativePath = path.relative(jsonDir, dir);
          const moduleBaseName = path.basename(file.name, '.json')
            .replace(/-/g, '');
          
          // Store brand names if this is a brand file
          if (relativePath === 'brand') {
            brandModules.add(moduleBaseName);
          }
          
          // Store module information
          const moduleInfo = {
            folder: relativePath,
            name: moduleBaseName,
            fullPath: path.join(relativePath, moduleBaseName),
            type: relativePath.split(path.sep)[0],
            symbols: Object.keys(content)
          };
          
          for (const symbol of moduleInfo.symbols) {
            symbolDefinitionCache.set(symbol, moduleInfo);
          }
        } catch (error) {
          console.error(`âŒ Error processing ${fullPath}:`, error);
        }
      }
    }
  }

  scanDirectory(jsonDir);
}

/**
 * Generates import statements for a specific module
 */
function generateImports(moduleInfo) {
  const imports = new Set();
  
  // Add globalvalue import for all non-globals files
  if (moduleInfo.type !== 'globals') {
    imports.add(`import { globalvalue } from '../globals/globalvalue';`);
  }
  
  // Add specific imports based on module type
  if (moduleInfo.type === 'theme') {
    const brandName = moduleInfo.name.replace(/light|dark/g, '');
    imports.add(`import { ${brandName} } from '../brand/${brandName}';`);
  } else if (moduleInfo.type === 'brand' && moduleInfo.name.endsWith('components')) {
    const brandName = moduleInfo.name.replace('components', '');
    imports.add(`import { ${brandName}light } from '../theme/${brandName}light';`);
    imports.add(`import { ${brandName}dark } from '../theme/${brandName}dark';`);
  }
  
  return Array.from(imports).join('\n');
}

/**
 * Process references in JSON values to match the new structure
 */
function processReferences(obj, brandName, moduleType) {
  return JSON.stringify(obj, (key, value) => {
    if (typeof value === 'string' && value.startsWith('{')) {
      // Update references based on module type and brand
      if (moduleType === 'theme') {
        return value.replace(/\{brand\./g, `{${brandName}.`);
      }
    }
    return value;
  }, 2).replace(/"([^"]+)":/g, (match, p1) => 
    p1.includes("-") ? `'${p1}':` : `${p1}:`);
}

/**
 * Converts brand JSON files into multiple TypeScript files
 */
function convertBrandToTs(brandPath, brandName) {
  try {
    const jsonContent = JSON.parse(fs.readFileSync(brandPath, 'utf8'));
    const { base, components } = splitBrandFile(brandName, jsonContent);
    
    // Generate base brand file
    const basePath = path.join(tsDir, 'brand', `${brandName}.ts`);
    const baseContent = `// Generated by convert-theme.js
import { globalvalue } from '../globals/globalvalue';

export const ${brandName} = ${processReferences(base, brandName, 'brand')};
`;
    
    // Generate components file
    const componentsPath = path.join(tsDir, 'brand', `${brandName}components.ts`);
    const componentsContent = `// Generated by convert-theme.js
import { globalvalue } from '../globals/globalvalue';
import { ${brandName}light } from '../theme/${brandName}light';
import { ${brandName}dark } from '../theme/${brandName}dark';

export const ${brandName}components = ${processReferences(components, brandName, 'components')};
`;
    
    // Write files
    ensureDirectoryExistence(basePath);
    fs.writeFileSync(basePath, baseContent);
    fs.writeFileSync(componentsPath, componentsContent);
    
    console.log(`âœ… Generated brand files for ${brandName}`);
  } catch (error) {
    console.error(`âŒ Error processing brand ${brandName}:`, error);
  }
}

/**
 * Converts theme JSON files into brand-specific TypeScript files
 */
function convertThemeToTs(themePath, themeName) {
  try {
    const themeContent = JSON.parse(fs.readFileSync(themePath, 'utf8'));
    
    // Generate theme file for each brand
    for (const brandName of brandModules) {
      const brandThemePath = path.join(tsDir, 'theme', `${brandName}${themeName}.ts`);
      const brandTheme = createThemeVariation(themeContent, brandName, themeName);
      
      const content = `// Generated by convert-theme.js
import { globalvalue } from '../globals/globalvalue';
import { ${brandName} } from '../brand/${brandName}';

export const ${brandName}${themeName} = ${processReferences(brandTheme, brandName, 'theme')};
`;
      
      ensureDirectoryExistence(brandThemePath);
      fs.writeFileSync(brandThemePath, content);
      
      console.log(`âœ… Generated ${themeName} theme for ${brandName}`);
    }
  } catch (error) {
    console.error(`âŒ Error processing theme ${themeName}:`, error);
  }
}

function convertAllFiles() {
  console.log("ðŸ” Building symbol definition map...");
  buildSymbolDefinitionMap();
  
  console.log("ðŸ“¦ Converting files...");
  
  // Process brand files
  brandModules.forEach(brandName => {
    const brandPath = path.join(jsonDir, 'brand', `${brandName}.json`);
    convertBrandToTs(brandPath, brandName);
  });
  
  // Process theme files
  ['light', 'dark'].forEach(theme => {
    const themePath = path.join(jsonDir, 'theme', `${theme}.json`);
    convertThemeToTs(themePath, theme);
  });
  
  // Convert globals
  const globalsPath = path.join(jsonDir, 'globals', 'globalvalue.json');
  const globalsContent = JSON.parse(fs.readFileSync(globalsPath, 'utf8'));
  const globalsOutput = path.join(tsDir, 'globals', 'globalvalue.ts');
  
  ensureDirectoryExistence(globalsOutput);
  fs.writeFileSync(globalsOutput, `// Generated by convert-theme.js
export const globalvalue = ${JSON.stringify(globalsContent, null, 2)};
`);
  
  console.log("âœ¨ Conversion complete!");
}

// Start conversion
convertAllFiles();