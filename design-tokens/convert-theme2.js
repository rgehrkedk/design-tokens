import fs from "fs";
import path from "path";
import { fileURLToPath } from "url";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const jsonDir = path.join(__dirname, "json");
const tsDir = path.join(__dirname, "ts");

function ensureDirectoryExistence(filePath) {
  const dirname = path.dirname(filePath);
  if (!fs.existsSync(dirname)) {
    fs.mkdirSync(dirname, { recursive: true });
  }
}

/**
 * Parses a reference string into its components
 */
function parseReference(value) {
  if (typeof value === 'string' && value.startsWith('{') && value.endsWith('}')) {
    return value.slice(1, -1).split('.');
  }
  return null;
}

/**
 * Converts a value object into a direct reference
 */
function processValue(value, options = {}) {
  const { currentBrand = '', parentKeys = [] } = options;

  // If it's a value object, process its value property
  if (value && typeof value === 'object' && 'value' in value) {
    const reference = parseReference(value.value);
    if (reference) {
      // Handle different types of references
      if (reference[0] === 'brand') {
        reference[0] = currentBrand;
        return reference.join('.');
      } else if (reference[0] === 'background' || reference[0] === 'foreground' || reference[0] === 'components') {
        // These are self-references within the theme
        return reference.join('.');
      } else {
        // These are typically globalvalue references
        return `globalvalue.${reference.join('.')}`;
      }
    }
    return value.value; // If it's not a reference, return the raw value
  }

  // If it's a direct string reference
  if (typeof value === 'string' && value.startsWith('{')) {
    return processValue({ value }, options);
  }

  return value;
}

/**
 * Processes an object's values and maintains the correct structure
 */
function processTokenObject(obj, options = {}) {
  const result = {};

  for (const [key, value] of Object.entries(obj)) {
    if (value && typeof value === 'object' && !('value' in value)) {
      result[key] = processTokenObject(value, options);
    } else {
      result[key] = processValue(value, options);
    }
  }

  return result;
}

/**
 * Creates the TypeScript content for a theme file
 */
function createThemeContent(themeData, options) {
  const { brandName, variation } = options;
  const processed = processTokenObject(themeData, { currentBrand: brandName });
  
  return `// Generated by convert-theme2.js
import { globalvalue } from '../globals/globalvalue';
import { ${brandName} } from '../brand/${brandName}';
import { ${brandName}components } from '../brand/${brandName}components';

export const ${brandName}${variation} = ${JSON.stringify(processed, null, 2)
    .replace(/"([^"]+)":/g, (_, p1) => p1.includes('-') ? `'${p1}':` : `${p1}:`)
    .replace(/"([^"]+)\.([^"]+)"/g, '$1.$2')};
`;
}

/**
 * Main conversion function
 */
function convertFiles() {
  console.log("🔍 Starting conversion process...");

  // Process each brand
  const brandFiles = fs.readdirSync(path.join(jsonDir, 'brand'))
    .filter(f => f.endsWith('.json'));

  for (const brandFile of brandFiles) {
    const brandName = path.basename(brandFile, '.json').replace(/-/g, '');
    console.log(`📦 Processing brand: ${brandName}`);

    // Read and process brand content
    const brandContent = JSON.parse(
      fs.readFileSync(path.join(jsonDir, 'brand', brandFile), 'utf8')
    );

    // Split brand content
    const { components, ...brandBase } = brandContent;

    // Process base brand file
    const processedBase = processTokenObject(brandBase);
    const baseContent = `// Generated by convert-theme2.js
export const ${brandName} = ${JSON.stringify(processedBase, null, 2)
  .replace(/"([^"]+)":/g, (_, p1) => p1.includes('-') ? `'${p1}':` : `${p1}:`)};
`;

    // Process components file
    const processedComponents = processTokenObject(components);
    const componentsContent = `// Generated by convert-theme2.js
import { ${brandName}light } from '../theme/${brandName}light';
import { ${brandName}dark } from '../theme/${brandName}dark';

export const ${brandName}components = ${JSON.stringify(processedComponents, null, 2)
  .replace(/"([^"]+)":/g, (_, p1) => p1.includes('-') ? `'${p1}':` : `${p1}:`)};
`;

    // Write brand files
    const basePath = path.join(tsDir, 'brand', `${brandName}.ts`);
    const componentsPath = path.join(tsDir, 'brand', `${brandName}components.ts`);
    
    ensureDirectoryExistence(basePath);
    fs.writeFileSync(basePath, baseContent);
    fs.writeFileSync(componentsPath, componentsContent);

    // Process theme variations
    ['light', 'dark'].forEach(variation => {
      const themeContent = JSON.parse(
        fs.readFileSync(path.join(jsonDir, 'theme', `${variation}.json`), 'utf8')
      );
      
      const themeOutput = createThemeContent(themeContent, { 
        brandName, 
        variation 
      });
      
      const themePath = path.join(tsDir, 'theme', `${brandName}${variation}.ts`);
      ensureDirectoryExistence(themePath);
      fs.writeFileSync(themePath, themeOutput);
    });
  }

  // Process globalvalue
  const globalContent = JSON.parse(
    fs.readFileSync(path.join(jsonDir, 'globals', 'globalvalue.json'), 'utf8')
  );
  
  const processedGlobal = processTokenObject(globalContent);
  const globalOutput = path.join(tsDir, 'globals', 'globalvalue.ts');
  
  ensureDirectoryExistence(globalOutput);
  fs.writeFileSync(globalOutput, `// Generated by convert-theme2.js
export const globalvalue = ${JSON.stringify(processedGlobal, null, 2)
  .replace(/"([^"]+)":/g, (_, p1) => p1.includes('-') ? `'${p1}':` : `${p1}:`)};
`);

  console.log("✨ Conversion complete!");
}

// Start conversion
convertFiles();