import fs from "fs";
import path from "path";
import { fileURLToPath } from "url";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const jsonDir = path.join(__dirname, "json");
const tsDir = path.join(__dirname, "ts");

// Cache for storing token definitions
const tokenCache = new Map();
const brandModules = new Set();

function ensureDirectoryExistence(filePath) {
  const dirname = path.dirname(filePath);
  if (!fs.existsSync(dirname)) {
    fs.mkdirSync(dirname, { recursive: true });
  }
}

/**
 * Analyzes a value to determine if it's a reference and returns the parsed path
 */
function parseReference(value) {
  if (typeof value === 'string' && value.startsWith('{') && value.endsWith('}')) {
    return value.slice(1, -1).split('.');
  }
  return null;
}

/**
 * Converts a reference path to a TypeScript accessor
 * e.g., "brand.primary.300" -> 'brand["primary"]["300"]'
 */
function convertToTypeScriptAccessor(parts) {
  return parts.map(part => {
    // If the part is numeric or contains special characters, use bracket notation
    return /^\d+$/.test(part) || part.includes('-') || part.includes(' ') ? 
      `["${part}"]` : 
      (parts.indexOf(part) === 0 ? part : `["${part}"]`);
  }).join('');
}

/**
 * Processes an object's values and converts references to TypeScript accessors
 */
function processObjectValues(obj, options = {}) {
  const { currentBrand = '' } = options;
  
  function processValue(value) {
    if (typeof value === 'string') {
      const reference = parseReference(value);
      if (reference) {
        // Handle different types of references
        if (reference[0] === 'brand') {
          // Replace brand with specific brand name
          reference[0] = currentBrand;
          return convertToTypeScriptAccessor(reference);
        } else if (reference[0] === 'neutrals' || reference[0] === 'feedback') {
          // These are typically from the globalvalue import
          return `globalvalue.${convertToTypeScriptAccessor(reference)}`;
        } else {
          return convertToTypeScriptAccessor(reference);
        }
      }
      // If it's a string but not a reference, keep it as a string literal
      return `"${value}"`;
    } else if (Array.isArray(value)) {
      return `[${value.map(v => processValue(v)).join(', ')}]`;
    } else if (typeof value === 'object' && value !== null) {
      return processObjectValues(value, options);
    }
    // For numbers, booleans, null, etc.
    return value;
  }

  const entries = Object.entries(obj).map(([key, value]) => {
    const processedValue = processValue(value);
    const formattedKey = key.includes('-') ? `'${key}'` : key;
    return `${formattedKey}: ${processedValue}`;
  });

  return `{\n  ${entries.join(',\n  ')}\n}`;
}

/**
 * Creates theme variation for a specific brand
 */
function createBrandThemeVariation(themeContent, brandName, variation) {
  const processed = processObjectValues(themeContent, { currentBrand: brandName });
  
  return `// Generated by convert-theme2.js
import { globalvalue } from '../globals/globalvalue';
import { ${brandName} } from '../brand/${brandName}';

export const ${brandName}${variation} = ${processed};
`;
}

/**
 * Processes a brand's base tokens
 */
function processBrandBase(brandContent, brandName) {
  const { components, ...brandBase } = brandContent;
  
  // Process base brand tokens
  const processedBase = processObjectValues(brandBase, { currentBrand: brandName });
  const baseContent = `// Generated by convert-theme2.js
import { globalvalue } from '../globals/globalvalue';

export const ${brandName} = ${processedBase};
`;

  // Process components with theme references
  const processedComponents = processObjectValues(components, { currentBrand: brandName });
  const componentsContent = `// Generated by convert-theme2.js
import { globalvalue } from '../globals/globalvalue';
import { ${brandName}light } from '../theme/${brandName}light';
import { ${brandName}dark } from '../theme/${brandName}dark';

export const ${brandName}components = ${processedComponents};
`;

  return { baseContent, componentsContent };
}

/**
 * Main conversion function
 */
function convertFiles() {
  console.log("🔍 Starting conversion process...");

  // First, scan for brand files
  const brandFiles = fs.readdirSync(path.join(jsonDir, 'brand'))
    .filter(f => f.endsWith('.json'));

  // Process each brand
  for (const brandFile of brandFiles) {
    const brandName = path.basename(brandFile, '.json').replace(/-/g, '');
    console.log(`📦 Processing brand: ${brandName}`);

    const brandContent = JSON.parse(
      fs.readFileSync(path.join(jsonDir, 'brand', brandFile), 'utf8')
    );

    // Process brand base and components
    const { baseContent, componentsContent } = processBrandBase(brandContent, brandName);
    
    // Write brand base file
    const basePath = path.join(tsDir, 'brand', `${brandName}.ts`);
    ensureDirectoryExistence(basePath);
    fs.writeFileSync(basePath, baseContent);
    
    // Write components file
    const componentsPath = path.join(tsDir, 'brand', `${brandName}components.ts`);
    fs.writeFileSync(componentsPath, componentsContent);

    // Process theme variations
    ['light', 'dark'].forEach(variation => {
      const themeContent = JSON.parse(
        fs.readFileSync(path.join(jsonDir, 'theme', `${variation}.json`), 'utf8')
      );
      
      const themeOutput = createBrandThemeVariation(themeContent, brandName, variation);
      const themePath = path.join(tsDir, 'theme', `${brandName}${variation}.ts`);
      ensureDirectoryExistence(themePath);
      fs.writeFileSync(themePath, themeOutput);
    });
  }

  // Process globalvalue
  const globalContent = JSON.parse(
    fs.readFileSync(path.join(jsonDir, 'globals', 'globalvalue.json'), 'utf8')
  );
  const globalOutput = path.join(tsDir, 'globals', 'globalvalue.ts');
  ensureDirectoryExistence(globalOutput);
  fs.writeFileSync(globalOutput, `// Generated by convert-theme2.js
export const globalvalue = ${processObjectValues(globalContent)};
`);

  console.log("✨ Conversion complete!");
}

// Start conversion
convertFiles();