import fs from "fs";
import path from "path";
import { fileURLToPath } from "url";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const jsonDir = path.join(__dirname, "json");
const tsDir = path.join(__dirname, "ts");

// Track what properties each brand defines
const brandDefinitions = new Map();

function ensureDirectoryExistence(filePath) {
  const dirname = path.dirname(filePath);
  if (!fs.existsSync(dirname)) {
    fs.mkdirSync(dirname, { recursive: true });
  }
}

/**
 * Scans brand files to determine what properties they define
 */
function scanBrandDefinitions() {
  const brandFiles = fs.readdirSync(path.join(jsonDir, 'brand'))
    .filter(f => f.endsWith('.json'));

  for (const brandFile of brandFiles) {
    const brandName = path.basename(brandFile, '.json').replace(/-/g, '');
    const content = JSON.parse(
      fs.readFileSync(path.join(jsonDir, 'brand', brandFile), 'utf8')
    );

    // Store top-level keys for each brand
    brandDefinitions.set(brandName, new Set(Object.keys(content)));
  }
}

/**
 * Determines if a property path is defined in a brand
 */
function isDefinedInBrand(brandName, propertyPath) {
  const brandProps = brandDefinitions.get(brandName);
  if (!brandProps) return false;

  // Check the first segment of the path
  const topLevel = propertyPath.split('.')[0];
  return brandProps.has(topLevel);
}

/**
 * Parses a reference string into its components
 */
function parseReference(value) {
  if (typeof value === 'string' && value.startsWith('{') && value.endsWith('}')) {
    return value.slice(1, -1).split('.');
  }
  return null;
}

/**
 * Creates a proper TypeScript property accessor
 */
function createPropertyAccessor(propertyPath) {
  return propertyPath.map(part => {
    // If the part is numeric or contains special characters, use bracket notation
    if (/^\d+$/.test(part) || part.includes('-') || part.includes(' ')) {
      return `["${part}"]`;
    }
    return `.${part}`;
  }).join('');
}

/**
 * Formats a reference into proper TypeScript code
 */
function formatReference(source, path) {
  return `${source}${createPropertyAccessor(path)}`;
}

/**
 * Determines the correct source for a reference
 */
function determineReferenceSource(reference, options) {
  const { currentBrand = '' } = options;
  const [firstPart, ...rest] = reference;

  // Self-references in the theme
  if (['background', 'foreground', 'components'].includes(firstPart)) {
    return formatReference(firstPart, rest);
  }

  // Brand references
  if (firstPart === 'brand') {
    return formatReference(currentBrand, ['brand', ...rest]);
  }

  // Feedback references
  if (firstPart === 'feedback') {
    return formatReference('globalvalue.feedback', rest);
  }

  // Check if property exists in brand
  if (isDefinedInBrand(currentBrand, firstPart)) {
    return formatReference(currentBrand, reference);
  }

  // Default to globalvalue
  return formatReference('globalvalue', reference);
}

/**
 * Processes a value and its references
 */
function processValue(value, options = {}) {
  if (value && typeof value === 'object' && 'value' in value) {
    const reference = parseReference(value.value);
    if (reference) {
      return determineReferenceSource(reference, options);
    }
    return JSON.stringify(value.value);
  }

  if (typeof value === 'string' && value.startsWith('{')) {
    return processValue({ value }, options);
  }

  return JSON.stringify(value);
}

/**
 * Processes an object's values and maintains the correct structure
 */
function processTokenObject(obj, options = {}) {
  const result = {};

  for (const [key, value] of Object.entries(obj)) {
    if (value && typeof value === 'object' && !('value' in value)) {
      result[key] = processTokenObject(value, options);
    } else {
      result[key] = processValue(value, options);
    }
  }

  return result;
}

/**
 * Creates the TypeScript content for a theme file
 */
function createThemeContent(themeData, options) {
  const { brandName, variation } = options;
  const processed = processTokenObject(themeData, { currentBrand: brandName });
  
  // Convert the processed object to a string with proper formatting
  const content = JSON.stringify(processed, null, 2)
    // Format property names
    .replace(/"([^"]+)":/g, (_, p1) => p1.includes('-') ? `'${p1}':` : `${p1}:`)
    // Clean up the reference strings
    .replace(/"([^"]+\.[^"]+(?:\["[^"]+"\])*)"/, '$1');

  return `// Generated by convert-theme2.js
import { globalvalue } from '../globals/globalvalue';
import { ${brandName} } from '../brand/${brandName}';
import { ${brandName}components } from '../brand/${brandName}components';

export const ${brandName}${variation} = ${content};
`;
}

/**
 * Main conversion function
 */
function convertFiles() {
  console.log("ðŸ” Starting conversion process...");

  // First scan brand definitions
  console.log("ðŸ“š Scanning brand definitions...");
  scanBrandDefinitions();

  // Process each brand
  const brandFiles = fs.readdirSync(path.join(jsonDir, 'brand'))
    .filter(f => f.endsWith('.json'));

  for (const brandFile of brandFiles) {
    const brandName = path.basename(brandFile, '.json').replace(/-/g, '');
    console.log(`ðŸ“¦ Processing brand: ${brandName}`);

    // Read and process brand content
    const brandContent = JSON.parse(
      fs.readFileSync(path.join(jsonDir, 'brand', brandFile), 'utf8')
    );

    // Split brand content
    const { components, ...brandBase } = brandContent;

    // Process base brand file
    const processedBase = processTokenObject(brandBase, { currentBrand: brandName });
    const baseContent = `// Generated by convert-theme2.js
export const ${brandName} = ${JSON.stringify(processedBase, null, 2)
  .replace(/"([^"]+)":/g, (_, p1) => p1.includes('-') ? `'${p1}':` : `${p1}:`)
  .replace(/"([^"]+\.[^"]+(?:\["[^"]+"\])*)"/, '$1')};
`;

    // Process components file
    const processedComponents = processTokenObject(components, { currentBrand: brandName });
    const componentsContent = `// Generated by convert-theme2.js
import { ${brandName}light } from '../theme/${brandName}light';
import { ${brandName}dark } from '../theme/${brandName}dark';

export const ${brandName}components = ${JSON.stringify(processedComponents, null, 2)
  .replace(/"([^"]+)":/g, (_, p1) => p1.includes('-') ? `'${p1}':` : `${p1}:`)
  .replace(/"([^"]+\.[^"]+(?:\["[^"]+"\])*)"/, '$1')};
`;

    // Write brand files
    const basePath = path.join(tsDir, 'brand', `${brandName}.ts`);
    const componentsPath = path.join(tsDir, 'brand', `${brandName}components.ts`);
    
    ensureDirectoryExistence(basePath);
    fs.writeFileSync(basePath, baseContent);
    fs.writeFileSync(componentsPath, componentsContent);

    // Process theme variations
    ['light', 'dark'].forEach(variation => {
      const themeContent = JSON.parse(
        fs.readFileSync(path.join(jsonDir, 'theme', `${variation}.json`), 'utf8')
      );
      
      const themeOutput = createThemeContent(themeContent, { 
        brandName, 
        variation 
      });
      
      const themePath = path.join(tsDir, 'theme', `${brandName}${variation}.ts`);
      ensureDirectoryExistence(themePath);
      fs.writeFileSync(themePath, themeOutput);
    });
  }

  // Process globalvalue
  const globalContent = JSON.parse(
    fs.readFileSync(path.join(jsonDir, 'globals', 'globalvalue.json'), 'utf8')
  );
  
  const processedGlobal = processTokenObject(globalContent);
  const globalOutput = path.join(tsDir, 'globals', 'globalvalue.ts');
  
  ensureDirectoryExistence(globalOutput);
  fs.writeFileSync(globalOutput, `// Generated by convert-theme2.js
export const globalvalue = ${JSON.stringify(processedGlobal, null, 2)
  .replace(/"([^"]+)":/g, (_, p1) => p1.includes('-') ? `'${p1}':` : `${p1}:`)
  .replace(/"([^"]+\.[^"]+(?:\["[^"]+"\])*)"/, '$1')};
`);

  console.log("âœ¨ Conversion complete!");
}

// Start conversion
convertFiles();