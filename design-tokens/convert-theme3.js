import { readdir, readFile, writeFile } from 'fs/promises';
import { join } from 'path';

// Types for design tokens and configuration
type TokenValue = string | number | Record<string, unknown>;
type ThemeVariant = 'light' | 'dark';

interface DesignToken {
    value: TokenValue;
    type?: string;
    description?: string;
}

interface TokenMap {
    [key: string]: DesignToken | TokenMap;
}

interface TokenFile {
    path: string;
    content: TokenMap;
}

// Token reference tracking
class TokenReferenceTracker {
    private referenceMap: Map<string, Set<string>> = new Map();
    private locationMap: Map<string, string> = new Map();

    addReference(token: string, referencedBy: string): void {
        if (!this.referenceMap.has(token)) {
            this.referenceMap.set(token, new Set());
        }
        this.referenceMap.get(token)!.add(referencedBy);
    }

    setLocation(token: string, location: string): void {
        this.locationMap.set(token, location);
    }

    getReferences(token: string): Set<string> {
        return this.referenceMap.get(token) || new Set();
    }
}

// File Discovery and Processing
async function discoverTokenFiles(rootDir: string = '/json'): Promise<string[]> {
    try {
        const files = await readdir(rootDir);
        return files
            .filter(file => file.endsWith('.json'))
            .map(file => join(rootDir, file));
    } catch (error) {
        console.error('Error discovering token files:', error);
        return [];
    }
}

async function loadTokenFile(path: string): Promise<TokenFile | null> {
    try {
        const content = await readFile(path, 'utf-8');
        return {
            path,
            content: JSON.parse(content) as TokenMap
        };
    } catch (error) {
        console.error(`Error loading token file ${path}:`, error);
        return null;
    }
}

// Token Processing
function processTokens(tokens: TokenMap, basePath: string = ''): Map<string, TokenValue> {
    const flattenedTokens = new Map<string, TokenValue>();
    
    function flatten(obj: TokenMap, path: string = '') {
        for (const [key, value] of Object.entries(obj)) {
            const currentPath = path ? `${path}.${key}` : key;
            
            if (isDesignToken(value)) {
                flattenedTokens.set(currentPath, value.value);
            } else {
                flatten(value, currentPath);
            }
        }
    }
    
    flatten(tokens, basePath);
    return flattenedTokens;
}

function resolveReferences(
    tokens: Map<string, TokenValue>,
    tracker: TokenReferenceTracker
): Map<string, TokenValue> {
    const resolved = new Map<string, TokenValue>();
    
    for (const [path, value] of tokens) {
        if (typeof value === 'string' && isTokenReference(value)) {
            const refPath = value.slice(1, -1); // Remove {} braces
            const resolvedValue = tokens.get(refPath);
            if (resolvedValue !== undefined) {
                resolved.set(path, resolvedValue);
                tracker.addReference(refPath, path);
            } else {
                console.warn(`Unresolved reference: ${value} in ${path}`);
                resolved.set(path, value);
            }
        } else {
            resolved.set(path, value);
        }
    }
    
    return resolved;
}

// TypeScript Generation
function generateTypeScript(
    tokens: Map<string, TokenValue>,
    tracker: TokenReferenceTracker
): string {
    const output: string[] = [];
    
    // Add type definitions
    output.push('// Generated by Design Token Converter');
    output.push('// Do not edit directly');
    output.push('');
    output.push('export interface DesignToken<T> {');
    output.push('  value: T;');
    output.push('  type?: string;');
    output.push('  description?: string;');
    output.push('}');
    output.push('');
    
    // Generate token structure
    output.push('export const tokens = {');
    
    const tokenPaths = Array.from(tokens.keys()).sort();
    for (const path of tokenPaths) {
        const value = tokens.get(path)!;
        const pathParts = path.split('.');
        const indentation = '  '.repeat(pathParts.length);
        
        output.push(`${indentation}${formatPropertyName(pathParts.at(-1)!)}: {`);
        output.push(`${indentation}  value: ${JSON.stringify(value)},`);
        output.push(`${indentation}} as const,`);
    }
    
    output.push('} as const;');
    output.push('');
    
    // Generate types
    output.push('export type TokenTypes = typeof tokens;');
    
    return output.join('\n');
}

// Helper functions
function isDesignToken(value: unknown): value is DesignToken {
    return typeof value === 'object' && value !== null && 'value' in value;
}

function isTokenReference(value: string): boolean {
    return value.startsWith('{') && value.endsWith('}');
}

function formatPropertyName(name: string): string {
    return name.replace(/-([a-z])/g, (_, letter) => letter.toUpperCase());
}

// Main conversion function
export async function convertDesignTokens(): Promise<void> {
    try {
        // Discover all JSON files
        const files = await discoverTokenFiles();
        if (files.length === 0) {
            throw new Error('No token files found in /json directory');
        }
        
        // Load and process all token files
        const tracker = new TokenReferenceTracker();
        const allTokens = new Map<string, TokenValue>();
        
        for (const file of files) {
            const tokenFile = await loadTokenFile(file);
            if (tokenFile) {
                const tokens = processTokens(tokenFile.content);
                for (const [path, value] of tokens) {
                    allTokens.set(path, value);
                }
            }
        }
        
        // Resolve references
        const resolvedTokens = resolveReferences(allTokens, tracker);
        
        // Generate TypeScript
        const typescript = generateTypeScript(resolvedTokens, tracker);
        
        // Write output
        await writeFile('tokens.ts', typescript);
        console.log('Successfully converted design tokens to TypeScript');
        
    } catch (error) {
        console.error('Error converting design tokens:', error);
        throw error;
    }
}

// Example usage:
convertDesignTokens().catch(console.error);